package higrt

import (
	"time"
)

type Action struct {
	Targets map[Address]lockKind
	F       func(map[Address]any) map[Address]any
}

type actionActor struct {
}

func (a *actionActor) Receive(context actor.Context) {}

func DoAction(context actor.RootContext, action Action) {
	if len(action.Targets) == 0 {
		panic("Attempted action with 0 targets!")
	}

	props := actor.PropsFromProducer(func() actor.Actor {
		return &actionActor{}
	}, actor.WithOnInit(func(ctx actor.Context) {
		txid := newTxid(ctx.Self())

	Try:
		for {

			// make a list of all the things we write to for later use
			writes := []Address{}
			for name, kind := range action.Targets {
				if kind == lockKindWrite {
					writes = append(writes, name)
				}
			}

			// request all locks
			for name, kind := range action.Targets {
				mailbox.Outbox <- OutboundMessage{Target: name, Content: varLockAcquireMessage{Txid: txid, Kind: kind}}
			}
			// wait to be granted all locks
			aborters := map[Address]struct{}{}
			lockResponseCount := 0
		WaitLocks:
			for inMsg := range mailbox.Inbox {
				switch inMsg.Content.(type) {
				case varLockGrantedMessage:
					lockResponseCount += 1
				case varLockFailedMessage:
					aborters[inMsg.Sender] = struct{}{}
				default:
					panic("Unexpected message")
				}

				if lockResponseCount == len(action.Targets)-len(aborters) {
					break WaitLocks
				}
			}

			if len(aborters) > 0 {
				for address := range action.Targets {
					if _, found := aborters[address]; found {
						continue
					}

					mailbox.Outbox <- OutboundMessage{Target: address, Content: varLockReleaseMessage{Txid: txid}}
				}

				time.Sleep(time.Millisecond * 5)
				continue Try
			}

			// request all reads
			for name := range action.Targets {
				mailbox.Outbox <- OutboundMessage{Target: name, Content: varReadMessage{Tx: tx{Id: txid, Writes: writes}}}
			}
			// wait to be granted all reads
			values := map[Address]any{}
			preds := []tx{}
			for inMsg := range mailbox.Inbox {
				if inContent, ok := inMsg.Content.(varReadResultMessage); ok {
					values[inMsg.Sender] = inContent.Value
					preds = append(preds, inContent.ValueProvides...)

					if len(values) == len(action.Targets) {
						break
					}
				}
			}

			// do all writes
			for name, value := range action.F(values) {
				if kind, ok := action.Targets[name]; !ok || kind != lockKindWrite {
					panic("invariant broken: action tries to write to variable it doesn't have a write lock for")
				}

				mailbox.Outbox <- OutboundMessage{Target: name, Content: varWriteMessage{Tx: tx{Id: txid, Writes: writes}, Requires: preds, Value: value}}
			}

			break
		}
	}))
	pid := context.Spawn(props)
	context.Stop(pid)
}
